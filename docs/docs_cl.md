Building Microphone class
1.	Creating a system where a mobile device can talk to another smart device involves several components, including acquiring audio from the microphone, encoding the audio, transmitting the audio, and then decoding and playing the audio on the receiving device. Example using JavaScript and WebRTC for audio communication between two devices in the same web application.

class Microphone {
    constructor() {
        this.stream = null;
        this.mediaConstraints = { audio: true };
    }

    async getAudioStream() {
        if (!this.stream) {
            this.stream = await navigator.mediaDevices.getUserMedia(this.mediaConstraints);
        }
        return this.stream;
    }

    stop() {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
    }
}

2.	Peer Connection: 
Using WebRTC's RTCPeerConnection for the communication:
const pcConfig = {
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
};

const localMicrophone = new Microphone();
const peerConnection = new RTCPeerConnection(pcConfig);

// When an ICE candidate is generated by the RTCPeerConnection
peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
        // Send this candidate to the other device (e.g., using a signaling server)
    }
};

// To start the call:
async function startCall() {
    const localStream = await localMicrophone.getAudioStream();
    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    // Send `offer` to the other device (e.g., using a signaling server)
}

// On receiving an answer (from the other device):
function handleAnswer(answer) {
    peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
}

// On receiving an ICE candidate (from the other device):
function addIceCandidate(candidate) {
    peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
}

Explanation:
3.	Signaling: This omits the signaling part, which is crucial for the devices to exchange SDP and ICE data. Signaling is often done using WebSocket or other messaging protocols.
4.	Receiving Device: The receiving device should create its own RTCPeerConnection, set the remote offer, generate an answer, and send that answer back. Also, when the RTCPeerConnection fires a track event, the received track should be attached to an audio element to be played.


